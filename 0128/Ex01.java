/*
 컴퓨터에서 음의 정수를 표현하기 위한 방법
 1) 부호와 절대치에 의한 방법  ---> 1Byte일 경우 : -127 ~ +127 
 2) 1의 보수에 의한 방법  ---> 1Byte일 경우 : -127 ~ +127
 3) 2의 보수에 의한 방법  ---> 1Byte일 경우 : -128 ~ +127  =====> 를 사용한다.
 실수를 표현하기 위한 방법으로는 부동 소숫점 표현 방식
 
 컴퓨터는 뺄셈을 못하는 기계이다. 뺄셈은 2의보수를 더해서 뺄셈
 # 9의 보수    # 10의보수
 	999          1000
   -236          -236 
 ------        ------
    763           764   
    9의 보수 + 1 = 10의 보수
    
    342			342
   -236        +764
-------     -------
    106        1106  ==> 맨 앞의 자리올림을 제거하면 결과는 106이다!!!!

       8421    
  7		111
 -4     100 ==> 011 + 1 ==> 100
 
        111
       +100
       ---- 
       1011 ===> 앞자리 버리기 011 ==> 3   
       
127 ==> 1 2 4 8 16 32 64 128 256 512 1024
        1111111 ==> 127
        +     1
        -------
       10000000  ==> byte일 경우 최상위 1비트는 부호비트이다. 0은 양수 1은 음수
       컴퓨터가 음수를 해석할때는 최상위비트로 부호를 판단하고 부호가 음수이면 숫자의 2의 보수를 음수를 사용한다.
       -
       01111111(1의보수) + 1 = 10000000  = 128 
       최종 결과는 -128이다.
       
       
       # 2진수 3자리는 8진수 한자리 ===> 000 ~ 111  ===> 0 ~ 7 ===> 8진수
       # 2진수 4자리는 16진수 한자리가 ===> 0000 ~ 1111  ===> 0 ~ 15 ==> 0 ~ 9 , a ~ f  ==> 16진수
       
       # 모든 비트가 1인 수 : 11111111 =>  2진수
                              377      =>  8진수
                              FF       => 16진수
                              255      => 10진수
 */


public class Ex01 {
	public static void main(String[] args) {
		// 다음 프로그램 중 문제가 되는곳은 어디일까요?
		byte b = 126;  // byte타입 : 1byte크기 ==> -128 ~ 127  ==> -(2의 n-1승) ~ +(2의 n-1승)-1   ----> 여기서 n은 bit수 
		System.out.println("b = " + b);

		b++; 		// 1증가
		System.out.println("b = " + b);

		b++;		// 1증가
		System.out.println("b = " + b);
		
		b--;		// 1감소
		System.out.println("b = " + b);
		
		b--;		// 1감소
		System.out.println("b = " + b);
		
	}
}
